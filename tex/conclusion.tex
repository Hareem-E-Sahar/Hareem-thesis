% A workaround to allow relative paths in included subfiles
% that are to be compiled separately
% See https://tex.stackexchange.com/questions/153312/subfiles-inside-a-subfile-using-relative-paths
\providecommand{\main}{..}
\documentclass[\main/thesis.tex]{subfiles}

%\onlyinsubfile{\zexternaldocument*{\main/tex/introduction}}

\begin{document}

\chapter{Conclusion}
\label{chp:conclusion}

\section{Limitations and Future Work}
Tree kernels can be used for program repair. %(see /home/hareem/ThinkpadP14/UofA2023/Tree_Kernel2024/NotesWinter2024.md)
%Parse tree kernels have been successfully used in natural language processing (NLP). However, the parse tree kernel used in NLP does not perform well for program source code due to two issues. The first issue is the asymmetric influence of node changes. In previous tree kernels, changes near a root node have larger influence than changes near leaf nodes. When the tree depth is small, this effect is not serious. However, the parse trees of program sources are much larger than that of natural language sentences, and this unwanted influence greatly affects tree comparison. The second issue is the sequence of subtrees. Previous tree kernels count sequence of subtrees. Unlike natural language sentences, the sequence of two substructures (like the order of two methods in a Java class) has little information in program source codes. We identified these two issues, and propose a new parse tree kernel for program source code.


%When processing ASTs structures, we usually face a problem of high-dimensional data. The size of an AST increases more than linearly when the program size is larger. In the experimental dataset, the largest AST contains 7027 nodes, while the program has only 343 lines of code including comments and blank lines. High-dimensional data not only lead to waste of time and memory but also aﬀect the performance of algorithms. Thus, dimension reduction is an essential task for the AST-based approach.

%Is IR a better method in general for SDP? Also, present lessons learnt from TK and present.

Referring back to the introduction (Section \ref{sec:motivation}), we see
that cross-references between files are correctly handled when the files
are compiled separately, and when the main document is compiled.
When the main document is compiled, cross-references are hyperlinked.
The values of the cross-references will change between the two compilation
scenarios, however. (Each chapter, compiled on its own, becomes ``Chapter 1''.)
\begin{note}[Caution:]
For cross-references to work, when files are compiled separately,
the referenced file must be compiled at least once before the
referring file is compiled.
\end{note}


%This thesis is timely and relevant because it addresses a foundational problem that persists regardless of how code is written: how reliably can we predict defects in evolving software systems? By demonstrating that defect prediction conclusions are unstable over time, your work cautions against naive trust in static models—whether traditional ML or LLM-based.
%
%In an era where code is produced faster than ever and by increasingly heterogeneous agents (humans and AI), robust, time-aware, and reproducible defect prediction is not optional—it is essential. Rather than making SDP obsolete, LLMs amplify the very challenges that motivated SDP research in the first place.


\end{document}